---
description: Guidelines for writing TypeScript code
globs: **/*.ts, **/*.tsx
---

# TypeScript Best Practices

Code must be strictly functional, declarative, and modular using React and TypeScript.

- **Stack:** Latest TypeScript, React, Node.js, Next.js App Router, Shadcn UI, TailwindCSS.
- **Restriction:** Avoid classes. Prioritize readability over performance unless specified.

## Strict Typing & Interfaces

- **Inheritance:** ALWAYS prefer `interface` over `type`. Avoid `&` (intersection) for performance.

  ```ts
  // BAD
  type C = A & B;
  // GOOD
  interface C extends A, B {}
  ```

- **Readonly**: Use `readonly` by default to prevent mutation.

  ```ts
  // BAD
  type User = { id: string; };
  // GOOD
  type User = { readonly id: string; };
  ```

- **NoUncheckedIndexedAccess**: Assume array/object access can return `undefined`.

## Imports & Exports

- **Named Exports**: ALWAYS use named exports. Avoid default exports unless required by framework (e.g., Next.js pages).

  ```ts
  // BAD
  export default function MyComponent() {}
  // GOOD
  export function MyComponent() {}
  ```

- **Type Imports**: Use top-level `import type`.

  ```ts
  // BAD
  import { type User } from "./user";
  // GOOD
  import type { User } from "./user";
  ```

## Enums

- **No Enums**: Do not introduce new enums. Use `as const` objects.
- **Reasoning**: Numeric enums have reverse mapping issues.

```ts
// BAD
enum Direction { Up, Down }

// GOOD
const Direction = {
  Up: "UP",
  Down: "DOWN",
} as const;

type Direction = (typeof Direction)[keyof typeof Direction];
```

## Generics & Any

- **Generics**: Prefix type parameters with T (e.g., TKey).
- **Any Usage**: Allow any only inside generic function bodies for necessary casting (e.g., matching runtime logic to conditional types).

```ts
// Allowed exception for casting inside generic function
const func = <T>(input: T): T => {
  return input as any; // distinct from logic
}
```

## Discriminated Unions

- Model Data: Use discriminated unions to prevent "bag of optionals".
- Switch: Use `switch` statements to handle states.

```ts
// BAD
type State<T> = { status: string; data?: T; error?: Error };

// GOOD
type State<T> =
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: Error };
```

## Optionals

- **Sparingly**: Use optional properties (`?`) extremely sparingly.
- **Explicit Unions**: Prefer `string | undefined` to force explicit handling.

```ts
// BAD - allows accidental omission
type Props = { userId?: string };

// GOOD - forces caller to pass undefined explicitly
type Props = { userId: string | undefined };
```

## Error Handling

- **Result Pattern**: Prefer returning a Result type over throwing errors for logic flow.

  ```ts
  type Result<T, E extends Error> = { ok: true; value: T } | { ok: false; error: E };

  // Usage
  const parseJson = (
    input: string,
  ): Result<unknown, Error> => {
    try {
      return { ok: true, value: JSON.parse(input) };
    } catch (error) {
      return { ok: false, error: error as Error };
    }
  };
  ```

- **Throwing**: Only throw if triggering a global handler (e.g., framework boundary).

## React & Next.js

- **Components**: Functional components only. No return type needed for components returning JSX.

  ```ts
  // No return type needed
  const MyComponent = () => <div>Hello</div>;
  ```

- **Rendering**: Favor RSC. Minimize `use client`. Wrap client components in Suspense.
- **Styling**: Shadcn UI + Tailwind CSS.

## Naming Conventions

- **Files**: `kebab-case` (`my-component.ts`)
- **Variables/Functions**: `camelCase` (`isLoading`, `fetchUser`)
- **Types**: `PascalCase` (`UserProfile`)
- **Constants**: `UPPER_CASE` (`MAX_RETRIES`)
- **Generics**: `T` prefix (`TValue`)

```ts
type RecordOfArrays<TItem> = Record<string, TItem[]>;
```

## Documentation

- JSDoc: Use for non-obvious logic.
- Links: Use `{@link}` for references.

## Development Workflow

- Completeness: No placeholders/TODOs.
- Dependencies: Use CLI (`pnpm add ...`), do not edit `package.json` manually.
